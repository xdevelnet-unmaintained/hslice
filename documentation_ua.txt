HSLICE передбачає формат даних і еталонну бібліотеку для розбору даних з цього формату. Еталонна реалізація бібліотеки іменується як libhslice.

 ########################################
 #          ОПИС ФОРМАТУ                #
 ########################################

1) Призначення 

	Формат HSLICE створений для того, щоб розділяти текстові дані на частини. Наприклад, щоб отримувати необхідні рядки з шаблонів веб сторінок на html, які можна в подальшому використовувати для динамічної генерації інших сторінок.

2) Формат

    Формат передбачає установку роздільників (делімітерів) між потрібними ділянками тексту. Роздільник має вигляд:

        PREFIXTAGSUFFIX

    Префікс і суфікс потрібні для того, щоб виділити тег серед іншої маси тексту і не створювати колізій.

    Наприклад:

        {COOLPREFIX_MYTAG}

    тут ми маємо:

        1) Префікс:    {COOLPREFIX_
        2) Тег:        MYTAG
        3) Суфікс:    }

    Роздільники мають можливість отримати доступ до тексту, який знаходиться перед роздільником.

3) Особливі випадки

	- Якщо перед роздільником знаходиться інший роздільник, або відсутній текст, ми отримуємо порожній рядок.

	- Тег NULL має особливе призначення. Він потрібен для позначення ділянки, яку слід ігнорувати.

	Наприклад:

		Get the roll{Z_ROLL} of the {Z_NULL}troll{Z_TROLL}

	У цьому прикладі при зверненні до ROLL ми отримаємо рядок "Get the roll", а при зверненні до TROLL маємо "troll". Текст " of the " не зобов’язаний потрапляти в пам'ять після роботи бібліотеки. libhslice не поміщає цей текст в пам’ять.

	- Спеціальні парні теги SKIP - NOSKIP. Вони працюють як NULL, однак наступний за NOSKIP тег захоплює текст, який знаходиться перед SKIP.

	Наприклад:

		Get{Z_GET} the roll {Z_SKIP}of {Z_NOSKIP}the troll{Z_MAINSTRING}

	MAINSTRING в цьому випадку поверне «the roll the troll".

	- Інколи потрібно, аби частина тексту не сприймалася як роздільник. Для цього його слід екранувати парою префікс+суфікс.

	Наприклад:

		UNROLL THE TADPOLE OS UNCLOG {Z_}{Z_AA} THE FROG OS UNLOAD THE TOAD

 ################################################
 #     ОПИС СТАНДАРТУ HSLICE НА ПСЕВДОМОВІ      #
 ################################################

1) Відкриття файлу і підготовка до зчитування даних.

	hslice_obj hslice_open(filename);

	Функція використовує файл filename в якості джерела даних для роботи. Повертає об’єкт типу hslice_obj, який є аргументом для інших функцій. Якщо потрібно інше джерело даних, можна передати порожнє значення, і функція створить порожній об’єкт, доступний для редагування розробником.

2) Завершення роботи з даними.

	void hslice_close(obj);

	Процедура завершує роботу з об’єктом obj, в подальшому ми можемо зруйнувати цей об’єкт.

3) Обробка даних

	sorted_list hslice_parse(obj, prefix, suffix);

	Функція обробляє дані з об’єкта obj, отримуючи асоціативний масив sorted_list з рядків. При обробці враховуються рядки prefix і suffix, які є префіксом і суфіксом відповідно.

4) Підрахунок отриманих даних

	int hslice_count(obj);

	Функція повертає отриману кількість рядків після обробки даних.

5) Список тегів

	list hslice_tags(obj);

	Функція повертає список рядків з відшуканими тегами.


 ##########################################################
 #       ОПИС API libhslice НА МОВІ ПРОГРАМУВАННЯ C       #
 ##########################################################

1) Відкриття файлу і підготовка до зчитування даних.

	hslice_obj *hslice_open(const char *filename);

	Функція відкриває файл filename, поміщає його вміст в пам'ять, закриває файл, потім оброблює дані. Повертає вказівник на структуру типу hslice_obj, який є аргументом для інших функцій бібліотеки. Якщо значення filename дорівнює NULL, або відбувається інша помилка, повертається NULL.

2) Завершення роботи з даними.

	void hslice_close(hslice_obj *obj);

	Процедура звільняє пам'ять, виділену під дані, що необхідні для роботи з obj. Працювати з obj, використовуючи функції бібліотеки не можна.

3) On-place обробка даних

	hslice_obj *hslice_parse(void *mem, size_t size, const char *prefix, const char *suffix, short int flags);

	Функція обробляє дані з області пам’яті. Повертає вказівник на структуру типу hslice_obj, або NULL у випадку невдачі. В залежності від використаних прапорців flags, отримана область пам’яті (не) буде змінена і/або реаллокована функцією realloc().

4) Підрахунок отриманих даних

	size_t hslice_count(hslice_obj *obj);

	Функція повертає отриману кількість рядків після обробки parse_hslice. Якщо обробка ще не була проведена, або спроба обробки завершилася невдачею (немає доступу до файлу, неможливо виділити пам'ять), повертається -1.

5) Вибірка

	const char *hslice_return(hslice_obj *obj, const char *search);

	Функція шукає в списку, отриманому після обробки obj, рядок з тегом search і повертає її. У разі відсутності результатів пошуку, повертається NULL.

	Примітка: Ця функція існує в еталонній бібліотеці з тієї причини, що в мові програмування С відсутні асоціативні масиви.

6) Рядкобезпечна вибірка

	const char *hslice_return_e(hslice_obj *obj, const char *search);

	Аналогічно з hslice_return(), але в разі відсутності результатів пошуку, повертається порожній рядок.

7) Повна вибірка

	tag_aznd_data *hslice_return_full(hslice_obj *obj, const char *search);

	Аналогічно з hslice_return(), але повертає структуру замість рядка. Структура містить рядок-тег, рядок-значення, розмір рядка-значення у байтах.

	Прототип структури:

	typedef struct {
		size_t length;
		char *tag;
		char *data;
	} tag_and_data;

7) Список тегів

	char **hslice_tags(hslice_obj *obj);

	Функція повертає вказівник на масив вказівників, кожен елемент з якого вказує на всі знайдені унікальні теги після виконання hslice_parse(). Останній елемент масиву завжди вказує на NULL.


 #########################################
 #         Приклади використання         #
 #########################################

1) Приклад використання формату  в html шаблоні

		<html>
			<head>
				<title>{PAGE_HEADER1}
				SOMETITILE{PAGE_NULL}
				</title>
			</head>{PAGE_HEADER2}
			<body>
				{PAGE_SKIP}FISHYTEXT and image <img src="troll.jpg">{PAGE_NOSKIP}
				<table>{PAGE_HEADER}
				    <tr class="line">{PAGE_TABLELINE}
				        <td class="cell1">{PAGE_CELL1}HUEHUEHUE{PAGE_NULL}</td>
				        <td class="cell2">{PAGE_CELL2}213123123123{PAGE_NULL}</td>
				    </tr>{PAGE_TABLELINE2}
				</table>
				<div class="footer">aaaa</div>
			</body>
		</html>{PAGE_ENDING}

2) Отримання даних

	Уявімо, що у нас є файл з ім’ям lorem.txt і таким змістом:

	Lorem ipsum dolor sit amet, consectetur adipiscing elit.{Z_O} {Z_NULL}Nunc egestas est id lacus viverra, et pharetra nulla sollicitudin.{Z_V} Vivamus ullamcorper orci est, et cursus nisl pretium nec. Donec pharetra, ipsum at commodo egestas, nibh tortor mollis sapien, eu mattis augue massa nec mi. Curabitur volutpat.

	Програма для отримання даних за тегами O і V:

		#include <stdio.h>
		#include "libhslice.h"

		int main(int argc, char **argv) {
			hslice_obj a = hslice_open("lorem.txt");;
			hslice_parse(&a, "{Z_", "}");
			printf("string from O tag: %s\nstring from V tag: %s\n", hslice_return(&a, "O"), hslice_return(&a, "V"));
			hslice_close(&a);
			return 0;
		}

3) Отримання всіх даних з перевіркою на помилки

	Теги аналогічні попередньому прикладу.

		#include <stdio.h>
		#include <stdlib.h>
		#include "libhslice.h"

		int main(int argc, char **argv) {
			hslice_obj a;
			int count;

			if (argc > 2) a = hslice_open(argv[1]);
			if (hslice_count(a) < 0) return EXIT_FAILURE;
			hslice_parse(a);
			count = hslice_count(a);
			if (count == 0) {
				fprintf(stderr, "No data recieved\n");
				return EXIT_SUCCESS;
			}
			size_t i = 0;
			while (i < count) {
				printf("%s %s\n", hslice_tags(a)[i], hslice_return(a, hslice_tags(a)[i]));
				i++;
			}
			return EXIT_SUCCESS;
		}

 ########################################################
 #      Невизначені поведінки, обмеження, зміни         #
 ########################################################

Стандарт:

	1) Стандарт потрібен для того, щоб визначити мінімальний сумісний функціонал.
	2) Все, що не визначене стандартом – дозволено.

Еталонна реалізація:

	1) Еталонна реалізація створена для того, щоб максимально коректно виконувати поставлене завдання – обробляти формат HSLICE в список рядків і давати можливість робити вибірку з цих рядків. Продуктивність, обсяг займаної пам’яті, і інші оптимізації не є цілями еталонної реалізації;
	2) Еталонну реалізацію можна сміливо використовувати в ситуаціях, коли відносно великий витрачений час і пам'ять на підготовку даних і вибірку є допустимим. У випадках, коли потрібно прискорити доступ до потрібної пам’яті, результати вибірки слід зберігати у вказівник, потім використовувати вже його;
	3) Прототип структури tag_and_data насправді використовує "union" замість "char *", що містить у собі типи "size_t" та "char *".
