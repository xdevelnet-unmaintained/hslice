HSLICE предполагает формат данных и эталонную библиотеку для разбора данных из этого формата. Эталонная реализация библиотеки именуется как libhslice.

########################################
#          ОПИСАНИЕ ФОРМАТА            #
########################################

1) Назначение

	Формат HSLICE создан для того, чтобы разделять текстовые данные на части. Например, чтобы получать требуемые строки из шаблонов вэб страниц на html, которые можно в последующем использовать для динамической генерации других страниц.

2) Формат

	Формат предполагает установку разделителей (делимитеров) между нужными участками текста. Разделитель имеет вид:

		PREFIXTAGSUFFIX

	Префикс и суффикс нужны для того, чтобы выделить тег среди остальной массы текста и не создавать коллизий.

	Например:

		{COOLPREFIX_MYTAG}

	тут мы имеем:

		1) Префикс:    {COOLPREFIX_
		2) Тег:        MYTAG
		3) Суффикс:    }

	Разделители дают возможность получить доступ к тексту, который находится перед разделителем.

3) Особые случаи

	- Если перед разделителем находится другой разделитель, либо отсутствующий текст, мы получаем пустую строку.

	- Тег NULL имеет особое назначение. Он нужен для обозначения участка, который следует игнорировать.

	Например:

		Get the roll{Z_ROLL} of the {Z_NULL}troll{Z_TROLL}

	В этом примере при обращении к ROLL мы получим строку "Get the roll", а при обращении к TROLL имеем "troll". Текст " of the " не обязан попадать в память после работы библиотеки. libhslice не помещает этот текст в память.

	- Специальные парные теги SKIP - NOSKIP. Они работают как NULL, однако следующий за NOSKIP тег захватывает текст, который находится перед SKIP.

	Например:

		Get{Z_GET} the roll {Z_SKIP}of {Z_NOSKIP}the troll{Z_MAINSTRING}

	MAINSTRING в этом случае вернет " the roll the troll".

	- Иногда нужно, чтобы участок текста не воспринимался как разделитель. Для этого его следует экранировать парой префикс+суффикс.

	Например:

		UNROLL THE TADPOLE OS UNCLOG {Z_}{Z_AA} THE FROG OS UNLOAD THE TOAD


################################################
#   ОПИСАНИЕ СТАНДАРТА HSLICE НА ПСЕВДОЯЗЫКЕ   #
################################################

1) Открытие файла и подготовка к считыванию данных.

	hslice_obj hslice_open(filename);

	Функция использует файл filename в качестве источника данных для работы. Возвращает объект типа hslice_obj, который является аргументом для других функций. Если требуется другой источник данных, можно передать пустое значение, и функция создаст пустой объект, доступный для редактирования разработчиком.

2) Завершение работы с данными.

	void hslice_close(obj);

	Процедура завершает работу с объектом obj, в последующем мы можем разрушить этот объект.

3) Обработка данных

	sorted_list hslice_parse(obj, prefix, suffix);

	Функция обрабатывает данные из объекта obj, получая ассоциативный массив sorted_list из строк. При обработке учитываются строки prefix и suffix, которые являются префиксом и суффиксом соответственно.

4) Подсчет полученных данных

	int hslice_count(obj);

	Функция возвращает полученное количество строк после обработки данных.

5) Список тегов

	list hslice_tags(obj);

	Функция возвращает список строк с найденными тегами.


##########################################################
#   ОПИСАНИЕ API libhslice НА ЯЗЫКЕ ПРОГРАММИРОВАНИЯ C   #
##########################################################

1) Открытие файла и подготовка к считыванию данных.

	hslice_obj hslice_open(const char *filename);

	Функция открывает файл filename, помещает его содержимое в память, затем закрывает файл. Возвращает структуру типа hslice_obj, которая является аргументом для других функций библиотеки. Если значение filename равно NULL, возвращается пустая структура.

2) Завершение работы с данными.

	void hslice_close(hslice_obj *obj);

	Процедура освобождает память, выделенную под данные, на которую указывает структура obj, а также очищает поля в ней. Работать с obj используя функции библиотеки нельзя.

3) Обработка данных

	void hslice_parse(hslice_obj *obj, char *prefix, char *suffix);

	Функция обрабатывает данные из hslice_obj в список строк, затем сортирует его для ускоренного доступа.

4) Подсчет полученных данных

	int hslice_count(hslice_obj *obj);

	Функция возвращает полученное количество строк после обработки parse_hslice. Если обработка еще не была произведена, либо попытка обработки завершилась неудачей (нет доступа к файлу, невозможно выделить память), возвращается -1.

5) Выборка

	char *hslice_return(hslice_obj *obj, char *search);

	Функция ищет в списке, полученном после обработки obj, строку с тегом search и возвращает её. В случае отсутствия результатов поиска, возвращается NULL.

	Примечание: Эта функция существует в эталонной библиотеке по той причине, что в языке программирования C отсуствуют ассоциативные массивы.

6) Строкобезопасная выборка

	char *hslice_return_e(hslice_obj *obj, char *search);

	Аналогично с hslice_return(), но в случае отсутствия результатов поиска, возвращается пустая строка.

7) Полная выборка

	tag_and_data *hslice_return_full(hslice_obj *obj, char *search);

	Аналогично hslice_return(), однако возвращает структуру вместо строки. Структура содержит строку-тег, строку-значение, размер строки-значения в байтах.

	Прототип структуры:

	typedef struct {
		size_t length;
		char *tag;
		char *data;
	} tag_and_data;

8) Список тегов

	char **hslice_tags(hslice_onj *obj);

	Функция возвращает указатель на массив указателей, каждый элемент из которого указывает на все найденные уникальные теги после выполнения hslice_parse(). Последний элемент массива всегда указывает на NULL.


########################################
#         Примеры использования        #
########################################

1) Пример использования формата в html шаблоне

		<html>
			<head>
				<title>{PAGE_HEADER1}
				SOMETITILE{PAGE_NULL}
				</title>
			</head>{PAGE_HEADER2}
			<body>
				{PAGE_SKIP}FISHYTEXT and image <img src="troll.jpg">{PAGE_NOSKIP}
				<table>{PAGE_HEADER}
					<tr class="line">{PAGE_TABLELINE}
						<td class="cell1">{PAGE_CELL1}HUEHUEHUE{PAGE_NULL}</td>
						<td class="cell2">{PAGE_CELL2}213123123123{PAGE_NULL}</td>
					</tr>{PAGE_TABLELINE2}
				</table>
				<div class="footer">aaaa</div>
			</body>
		</html>{PAGE_ENDING}

2) Получение данных

	Представим что у нас есть файл с именем lorem.txt и таким содержанием:

	Lorem ipsum dolor sit amet, consectetur adipiscing elit.{Z_O} {Z_NULL}Nunc egestas est id lacus viverra, et pharetra nulla sollicitudin.{Z_V} Vivamus ullamcorper orci est, et cursus nisl pretium nec. Donec pharetra, ipsum at commodo egestas, nibh tortor mollis sapien, eu mattis augue massa nec mi. Curabitur volutpat.

	Программа для получения данных по тегам O и V:

		#include <stdio.h>
		#include "libhslice.h"

		int main(int argc, char **argv) {
			hslice_obj a = hslice_open("lorem.txt");;
			hslice_parse(a, "{Z_", "}");
			printf("%s %s", hslice_return(a, "O"), hslice_return(a, "V"));
			return 0;
		}

3) Получение всех данных с проверкой на ошибки

	Теги аналогичны предыдущему примеру.

		#include <stdio.h>
		#include <stdlib.h>
		#include "libhslice.h"

		int main(int argc, char **argv) {
			hslice_obj a;
			int count;

			if (argc > 2) a = hslice_open(argv[1]);
			if (hslice_count(a) < 0) return EXIT_FAILURE;
			hslice_parse(a);
			count = hslice_count(a);
			if (count == 0) {
				fprintf(stderr, "No data recieved\n");
				return EXIT_SUCCESS;
			}
			size_t i = 0;
			while (i < count) {
				printf("%s %s\n", hslice_tags(a)[i], hslice_return(a, hslice_tags(a)[i]));
				i++;
			}
			return EXIT_SUCCESS;
		}

########################################################
#   Неопределенные поведения, ограничения, замечения   #
########################################################

Стандарт:

	1) Стандарт нужен для того, чтобы определить минимальный совместимый функционал.
	2) Всё, что не определено стандартом - разрешено.

Эталонная реализация:

	1) Эталонная реализация создана для того, чтобы максимально корректно выполнять поставленную задачу - обрабатывать формат HSLICE в список строк и давать возможность производить выборку из этих строк. Производительность, объем занимаемой памяти, и другие оптимизации не являются целями эталонной реализации;
	2) Эталонную реализацию можно смело использовать в ситуациях, когда относительно большое затрачиваемое время и память на подготовку данных и выборку является допустимым. В случаях, когда требуется ускорить доступ к нужной памяти, результаты выборки следует сохранять в указатель, затем использовать уже его;
	3) Прототип структуры tag_and_data на самом деле использует "union" вместо "char *", который содержит типы "size_t" и "char *".
